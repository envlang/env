using System;

// This file was generated by Generator.cs

public static partial class Lexer {

  /* To match against an instance of S, write:
     x.Match(
       End: () => throw new NotImplementedYetException(),,
       Space: () => throw new NotImplementedYetException(),,
       Int: () => throw new NotImplementedYetException(),,
       Decimal: () => throw new NotImplementedYetException(),,
       String: () => throw new NotImplementedYetException(),,
       StringOpen: () => throw new NotImplementedYetException(),,
       StringClose: () => throw new NotImplementedYetException(),
     )
  */
  public abstract class S {
    public abstract T Match_<T>(Visitor<T> c);
    public static S End = new End();
    public static S Space = new Space();
    public static S Int = new Int();
    public static S Decimal = new Decimal();
    public static S String = new String();
    public static S StringOpen = new StringOpen();
    public static S StringClose = new StringClose();
    public virtual Immutable.Option<End> AsEnd() => Immutable.Option.None<End>();
    public virtual Immutable.Option<Space> AsSpace() => Immutable.Option.None<Space>();
    public virtual Immutable.Option<Int> AsInt() => Immutable.Option.None<Int>();
    public virtual Immutable.Option<Decimal> AsDecimal() => Immutable.Option.None<Decimal>();
    public virtual Immutable.Option<String> AsString() => Immutable.Option.None<String>();
    public virtual Immutable.Option<StringOpen> AsStringOpen() => Immutable.Option.None<StringOpen>();
    public virtual Immutable.Option<StringClose> AsStringClose() => Immutable.Option.None<StringClose>();
    private string GetTag() {
      return this.Match(
        End: () => "End",
        Space: () => "Space",
        Int: () => "Int",
        Decimal: () => "Decimal",
        String: () => "String",
        StringOpen: () => "StringOpen",
        StringClose: () => "StringClose"
      );
    }
  }

  public partial class Visitor<T> { public Func<T> End { get; set; } }

  public sealed class End : S {
    public End() { }
    public override T Match_<T>(Visitor<T> c) => c.End();
    public override Immutable.Option<End> AsEnd() => Immutable.Option.Some<End>(this);
    public override bool Equals(object other) {
        return (other is End);
    }
    public override int GetHashCode() {
        return "C".GetHashCode();
    }
  }

  public partial class Visitor<T> { public Func<T> Space { get; set; } }

  public sealed class Space : S {
    public Space() { }
    public override T Match_<T>(Visitor<T> c) => c.Space();
    public override Immutable.Option<Space> AsSpace() => Immutable.Option.Some<Space>(this);
    public override bool Equals(object other) {
        return (other is Space);
    }
    public override int GetHashCode() {
        return "C".GetHashCode();
    }
  }

  public partial class Visitor<T> { public Func<T> Int { get; set; } }

  public sealed class Int : S {
    public Int() { }
    public override T Match_<T>(Visitor<T> c) => c.Int();
    public override Immutable.Option<Int> AsInt() => Immutable.Option.Some<Int>(this);
    public override bool Equals(object other) {
        return (other is Int);
    }
    public override int GetHashCode() {
        return "C".GetHashCode();
    }
  }

  public partial class Visitor<T> { public Func<T> Decimal { get; set; } }

  public sealed class Decimal : S {
    public Decimal() { }
    public override T Match_<T>(Visitor<T> c) => c.Decimal();
    public override Immutable.Option<Decimal> AsDecimal() => Immutable.Option.Some<Decimal>(this);
    public override bool Equals(object other) {
        return (other is Decimal);
    }
    public override int GetHashCode() {
        return "C".GetHashCode();
    }
  }

  public partial class Visitor<T> { public Func<T> String { get; set; } }

  public sealed class String : S {
    public String() { }
    public override T Match_<T>(Visitor<T> c) => c.String();
    public override Immutable.Option<String> AsString() => Immutable.Option.Some<String>(this);
    public override bool Equals(object other) {
        return (other is String);
    }
    public override int GetHashCode() {
        return "C".GetHashCode();
    }
  }

  public partial class Visitor<T> { public Func<T> StringOpen { get; set; } }

  public sealed class StringOpen : S {
    public StringOpen() { }
    public override T Match_<T>(Visitor<T> c) => c.StringOpen();
    public override Immutable.Option<StringOpen> AsStringOpen() => Immutable.Option.Some<StringOpen>(this);
    public override bool Equals(object other) {
        return (other is StringOpen);
    }
    public override int GetHashCode() {
        return "C".GetHashCode();
    }
  }

  public partial class Visitor<T> { public Func<T> StringClose { get; set; } }

  public sealed class StringClose : S {
    public StringClose() { }
    public override T Match_<T>(Visitor<T> c) => c.StringClose();
    public override Immutable.Option<StringClose> AsStringClose() => Immutable.Option.Some<StringClose>(this);
    public override bool Equals(object other) {
        return (other is StringClose);
    }
    public override int GetHashCode() {
        return "C".GetHashCode();
    }
  }

}
public static class SExtensionMethods {
  public static T Match<T>(
      this Lexer.S e,
      Func<T> End,
      Func<T> Space,
      Func<T> Int,
      Func<T> Decimal,
      Func<T> String,
      Func<T> StringOpen,
      Func<T> StringClose
    ) {
    return e.Match_(new Lexer.Visitor<T> {
      End = End,
      Space = Space,
      Int = Int,
      Decimal = Decimal,
      String = String,
      StringOpen = StringOpen,
      StringClose = StringClose
    });
  }
}
